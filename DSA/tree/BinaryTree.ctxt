#BlueJ class context
comment0.params=
comment0.target=java.lang.Object\ getValue()
comment0.text=\r\n\ gets\ the\ value\ at\ a\ particular\ spot\ in\ the\ tree\r\n\ @returns\ <E>\ the\ value\r\n
comment1.params=
comment1.target=BinaryTree\ getLeft()
comment1.text=\r\n\ returns\ the\ left\ and\ right\ child,\ respectively\ \r\n\ @return\ the\ left\ child\ and\ its\ children\r\n
comment10.params=
comment10.target=list.Iterator\ iterator()
comment10.text=\r\n\ @return\ an\ Iterator\ for\ this\ BinaryTree\r\n\ lots\ of\ ways\ this\ could\ work,\ left\ up\ to\ implementing\ class.\r\n\ \r\n\ Could\ decide\ to\ go\ pre\ order,\ in\ order,\ or\ post\ order.\ \r\n
comment11.params=
comment11.target=java.lang.String\ toString()
comment11.text=\r\n\ @return\ a\ String\ representation\ of\ this\ BinaryTree\r\n\ How?\ In\ what\ order?\ Could\ we\ use\ an\ Iterator?\r\n\ again,\ left\ up\ to\ implementation\r\n
comment12.params=
comment12.target=boolean\ isEmpty()
comment12.text=@return\ true\ only\ if\ this\ BinaryTree\ is\ empty
comment13.params=object
comment13.target=boolean\ equals(java.lang.Object)
comment13.text=@return\ true\ only\ if\ this\ BinaryTree\ is\ equal\ to\ the\ given\ obj
comment2.params=
comment2.target=BinaryTree\ getRight()
comment3.params=value
comment3.target=void\ setValue(java.lang.Object)
comment3.text=\r\n\ change\ the\ value\ of\ this\ BinaryTree\r\n
comment4.params=left
comment4.target=void\ setLeft(BinaryTree)
comment4.text=\r\n\ change\ the\ left\ child\r\n
comment5.params=right
comment5.target=void\ setRight(BinaryTree)
comment5.text=\r\n\ change\ the\ right\ child\r\n
comment6.params=value
comment6.target=BinaryTree\ add(java.lang.Object)
comment6.text=\r\n\ insert\ a\ given\ value\ somewhere\ into\ this\ tree\r\n\ Where?\ \ How?\ this\ is\ left\ up\ to\ the\ implementing\ class.\ Different\r\n\ Binary\ Trees\ will\ insert\ differently\ \r\n\ @return\ a\ ref\ to\ the\ updated\ tree\r\n
comment7.params=value
comment7.target=BinaryTree\ remove(java.lang.Object)
comment7.text=\r\n\ Remove\ the\ given\ value\ from\ this\ BinaryTree\r\n\ \!\!\!\!\r\n\ Keep\ in\ mind\ that\ when\ we\ remove\ something,\ we\ have\ to\ "fix"\ some\ of\ the\ leaves.\r\n\ If\ we\ remove\ something\ from\ the\ middle\ of\ the\ tree,\ how\ is\ the\ implementing\ class\ going\ to\ fix\ it?\r\n\ Again,\ left\ up\ to\ the\ implementing\ class./\r\n\ \!\!\!\!\r\n\ \r\n\ @return\ a\ ref\ to\ the\ updated\ tree\r\n
comment8.params=value
comment8.target=boolean\ containsKey(java.lang.Object)
comment8.text=\r\n\ returns\ true\ only\ if\ the\ given\ value\ exists\ in\ this\ Binary\ Tree\r\n\ @return\ true\ if\ this\ Binary\ Tree\ contains\ the\ given\ value\r\n
comment9.params=value
comment9.target=java.lang.Object\ get(java.lang.Object)
comment9.text=\r\n\ returns\ the\ value\ stored\ in\ the\ BinaryTree\ with\ the\ given\ value(...what?),\ or\ null\ if\ not\ found\r\n\ \r\n\ so\ why\ would\ we\ have\ a\ method\ that\ returns\ the\ value\ we\ give\ it?\ Its\ returning\ a\ ref\ to\ an\ object,\ and\r\n\ if\ we\ were\ only\ returning\ a\ value\ by\ say\ a\ name,\ we\ could\ have\ two\ names\ that\ are\ the\ same\ but\ ref\ DIFFERENT\r\n\ objects.\ So\ we\ compare\ against\ objects\ to\ make\ sure\ we\ return\ what\ the\ user\ wants.\r\n
numComments=14
